# Agent Rules for Dashboard Project

## Core Principles

### Before Starting Any Work

1. **ALWAYS** read README.md first to understand the project
2. **ALWAYS** understand the development cycle and rules
3. **ALWAYS** verify test environment is working

### During Implementation

1. **MANDATORY**: Follow TDD approach (tests first)
2. **MANDATORY**: Use design system tokens consistently
3. **MANDATORY**: Use Tailwind theme classes instead of hardcoded colors
4. **MANDATORY**: Implement comprehensive error handling
5. **MANDATORY**: Add accessibility features (WCAG 2.1 AA)
6. **MANDATORY**: Write clear documentation
7. **MANDATORY**: Test thoroughly before completion
8. **MANDATORY**: Check codebase structure for consistency

## Application Data Flow & Features

### API Logs System

- **Centralized Logging**: All errors and warnings generated by calling any tile API are preserved in local storage and presented in the API logs table
- **Logging Location**: Logging happens in `dataFetcher` service
- **Persistence**: Log persistence functions are handled by `storageManager`
- **Error Handling**: Errors are not returned back to tiles, but logged in API log for centralized monitoring
- **Log Display**: API logs are displayed in a dedicated table interface for debugging and monitoring

### Data Fetching Architecture

The dashboard uses a centralized data fetching pattern with the following flow:

#### Centralized Components:

- **API Endpoints**: Defined centrally in `src/services/apiEndpoints.ts`
- **Call Parameters & Mappers**: Defined per tile in their respective implementation folders
- **Execution Engine**: All API calls executed through `dataFetcher` service
- **Storage Management**: All data persistence handled by `storageManager`

#### Tile Data Handling:

- **Rendering Logic**: Tiles handle their rendering based on data and last request status from their storage
- **API Hooks**: Tile API hooks call `dataFetcher`
- **Error Isolation**: Errors are not returned to tiles but logged centrally
- **Data Persistence**: Tiles maintain their data state through storage manager
- **Runtime data**: Tiles have internal state with data and status which they access for rendering. This data gets updated when new data is returned by dataFetcher
- **Data Request Conditions**: Tiles request new data from API when one of these conditions are met:
  - Tile is initialized through adding to the board
  - Success status of last request is false
  - Time of data refetch interval is reached, defined per tile, or can be none

#### DataFetcher Decision Logic:

1. **No Data**: If no data exists in storage, perform fetch
2. **Successful Fetch**:
   - Update storage data, time, and status
   - Call mapper or parser for data transformation
   - Return mapped data to tile
3. **Failed Fetch**:
   - Log the error in API logs
   - Do not update tile data (preserve old or empty data)
   - Update only last request time and status
   - Return current tile data (old or empty) to the tile
4. **Timeout**:
   - There is internal timeout in datFetcher, which prevents frequent calls
   - can be overriden with forceRefresh flag passed by api hooks

#### Implementation Requirements:

- **Error Logging**: All API errors must be logged through the centralized logging system
- **Data Mappers**: Each tile must provide appropriate data mappers/parsers
- **Storage Keys**: Use consistent storage key patterns defined in `storageManager`
- **Status Tracking**: Maintain request status for proper error handling and UI state management

## Quality Gates

- [ ] All tests pass (>80% coverage)
- [ ] No TypeScript errors
- [ ] No linting warnings
- [ ] Build completes successfully
- [ ] Accessibility requirements met
- [ ] Performance benchmarks achieved
- [ ] Code structure is consistent and logical
- [ ] File organization follows project conventions

## Development Standards

### Code Quality

- **TypeScript**: Use strict mode, proper interfaces, type safety, avoid using string literals for parameters when a typed interface can be used
- **Testing**: >80% coverage for unit tests
- **Accessibility**: WCAG 2.1 AA compliance, ARIA labels, keyboard navigation
- **Performance**: <100ms component render times, optimized bundles
- **Documentation**: Clear comments, README updates, inline docs
- **Code Structure**: Logical organization, avoid duplication, use enums and constants
- **Abstraction**: Extract reusable patterns, avoid hardcoding business logic
- **Styling**: Use Tailwind theme classes instead of hardcoded colors
- **Linting**: ESLint for consistent code style
- **Formatting**: Maintain consistent formatting throughout

### Architecture Rules

- **Design System**: Use centralized tokens, consistent patterns
- **Component Patterns**: Functional components, composition over inheritance
- **Error Handling**: Proper boundaries, user-friendly messages
- **File Organization**: Logical structure, clear naming conventions
- **Code Abstraction**: Use enums, constants, and utility functions to avoid duplication
- **Business Logic**: Extract reusable patterns, avoid hardcoding values
- **Refactoring**: Continuously refactor to maintain clean, logical structure
- **Structure Checks**: Verify file naming, location, and responsibilities of each new file and component

### Dashboard-Specific Rules

- **Dragboard Agnosticism**: Dragboard must remain generic and agnostic of app-specific data and persistence. It must not contain or invoke any persistence, API, or business logic.
- **Tile Implementation Boundaries**: Generic tile definitions must not hardcode app-specific info. All specific info and data fetching must be provided by tile implementations, which must use the centralized dataFetcher and storageManager.
- **Centralized Managers**: All local storage and API/data fetching must be routed through storageManager and dataFetcher, respectively. No direct localStorage or fetch/axios usage is allowed outside these managers.
- **Data Fetching**: Use proper error handling and loading states. All data fetching must go through the centralized dataFetcher service.
- **State Management**: Use React hooks for component state. All persistence must go through storageManager.
- **Responsive Design**: Ensure dashboard works on all screen sizes
- **Performance**: Optimize for fast data updates and smooth interactions
- **Accessibility**: Ensure keyboard navigation works for all dashboard interactions
- **Real-time Updates**: Handle data refresh gracefully with loading states

### Project Structure Rules

- **Dashboard Components**: Keep in `src/components/dragboard/`
- **Tile Implementations**: Place in `src/components/tile-implementations/`
- **Data Services**: Organize in `src/services/`
- **UI Components**: Place in `src/components/ui/`
- **Utilities**: Place in `src/utils/`
- **Types**: Define in `src/types/`
- **Tests**: Co-locate with source files
- **Assets**: Store in `src/assets/`

## Agent Workflow

### MANDATORY Agent Behaviors

1. **ALWAYS** read README.md before any work
2. **ALWAYS** maintain >80% test coverage throughout
3. **ALWAYS** run tests with `npm run test:run`
4. **ALWAYS** update README.md with new completed features
5. **ALWAYS** refactor code to maintain logical structure and avoid duplication
6. **ALWAYS** use enums, constants, and abstraction to avoid hardcoding
7. **ALWAYS** fix any linting issues before proceeding
8. **ALWAYS** only implement features explicitly requested
9. **NEVER** run interactive commands that could hang
10. **NEVER** hallucinate or assume features not explicitly requested
11. **NEVER** add sections like 'future improvements' or 'potential enhancements'

### Testing Protocol

1. Fix any test failures before proceeding
2. Maintain >80% coverage throughout
3. **ALWAYS** create mocks for tests API endpoints
4. **NEVER** use real endpoint API calls in tests

### Build Protocol

1. **ALWAYS** run `npm run build` after completing a feature
2. Fix any TypeScript errors, linting issues, or build failures
3. Ensure the app builds successfully
4. If build fails, fix issues and rebuild until successful

### Code Quality Protocol

1. **ALWAYS** run `npm run check:all` after completing each feature
2. Fix any issues before proceeding
3. Ensure code follows project standards and conventions

### Structure Check Protocol

1. **ALWAYS** review file naming conventions for consistency
2. **ALWAYS** verify file locations match project structure
3. **ALWAYS** check file responsibilities are properly separated
4. **ALWAYS** fix any structural regressions before concluding PRP
5. **ALWAYS** ensure logical organization is maintained
6. **ALWAYS** verify code structure follows established patterns

### Documentation Protocol

1. Update archive README.md
2. Maintain comprehensive documentation of completed work
3. **ALWAYS** update project root README.md if tech stack or features have changed during implementation

### Code Structure Protocol

1. **ALWAYS** use enums and constants instead of hardcoded values
2. **ALWAYS** use Tailwind theme classes instead of hardcoded colors
3. **ALWAYS** extract reusable patterns and utility functions
4. **ALWAYS** refactor code when new additions cause structural issues
5. **ALWAYS** maintain logical file organization and component hierarchy
6. **ALWAYS** avoid duplication of business logic across files
7. **ALWAYS** use proper abstraction layers for complex operations
8. **ALWAYS** use typescript interfaces and generics, and type function parameters
9. **NEVER** leave hardcoded strings or magic numbers in code
10. **NEVER** use hardcoded color values in CSS or className
11. **NEVER** proceed without refactoring if code structure becomes unclear

## Implementation Standards

### Consistency

- Follow established patterns and conventions
- Use consistent naming conventions
- Maintain consistent code style

### Reusability

- Create reusable components and utilities
- Extract common patterns into shared utilities
- Design components for reuse

### Maintainability

- Write clean, documented, testable code
- Use proper TypeScript types
- Implement comprehensive error handling

### Scalability

- Design for future enhancements
- Use modular architecture
- Plan for extensibility

### Reliability

- Robust error handling and edge cases
- Comprehensive testing
- Graceful degradation

### Abstraction

- Use enums, constants, and utility functions to avoid hardcoding
- Extract business logic into reusable functions
- Create proper abstraction layers

## Agent Behavior Rules

### DO:

- Read README.md before any work
- Generate comprehensive PRPs with all details
- Implement features completely and thoroughly
- Run tests with `npm run test:run`
- Fix code quality issues before proceeding
- Update README.md with new completed features
- Update project root README.md if tech stack or features have changed
- Use Tailwind theme classes instead of hardcoded colors
- Maintain high test coverage
- Follow all quality standards
- Only implement explicitly requested features

### DON'T:

- Run interactive commands that could hang
- Use `npm test` (use `npm run test:run`)
- Skip reading README.md
- Ignore test failures
- Ignore linting issues
- Ignore typescript issues
- Forget to update README.md
- Hallucinate or assume features not requested
- Add sections like 'future improvements'
- Skip structure checks
